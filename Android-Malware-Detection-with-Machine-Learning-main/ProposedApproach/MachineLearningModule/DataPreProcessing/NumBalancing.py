import pandas as pd
import numpy as np
import logging

logger = logging.getLogger(__name__)


# --------------- Random Undersampling --------------- #
def random_undersampling(x, y):
    """
    Function to perform random undersampling.

    Input:
        x - data matrix
        y - targets

    Output:
        x - data matrix after random undersampling
        y - targets after random undersampling
    """
    # Combine features and target for easy sampling
    df = x.copy()
    df['__target__'] = y.values if hasattr(y, 'values') else y

    # Determine minority class size
    counts = df['__target__'].value_counts()
    min_count = counts.min()

    # Sample min_count from each class
    sampled = df.groupby('__target__', group_keys=False).apply(lambda g: g.sample(n=min_count, random_state=42))

    y_res = sampled['__target__'].reset_index(drop=True)
    x_res = sampled.drop(columns='__target__').reset_index(drop=True)

    return x_res, y_res


# --------------- Random Oversampling --------------- #
def random_oversampling(x, y):
    """
    Function to perform random oversampling.

    Input:
        x - data matrix
        y - targets

    Output:
        x - data matrix after random oversampling
        y - targets after random oversampling
    """
    df = x.copy()
    df['__target__'] = y.values if hasattr(y, 'values') else y

    # Determine majority class size
    counts = df['__target__'].value_counts()
    max_count = counts.max()

    # Oversample each class to match max_count
    sampled = df.groupby('__target__', group_keys=False).apply(lambda g: g.sample(n=max_count, replace=True, random_state=42))

    y_res = sampled['__target__'].reset_index(drop=True)
    x_res = sampled.drop(columns='__target__').reset_index(drop=True)

    return x_res, y_res


# --------------- Synthetic Minority Over-sampling TEchnique (SMOTE) --------------- #
def smote(x, y):
    """
    Function to perform Synthetic Minority Over-sampling TEchnique (SMOTE) with the 'minority' sampling strategy.

    Input:
        x - data matrix
        y - targets

    Output:
        x - data matrix after SMOTE
        y - targets after SMOTE
    """
    try:
        from imblearn.over_sampling import SMOTE
    except Exception:
        logger.warning("imblearn.SMOTE not available; falling back to random oversampling for SMOTE()")
        return random_oversampling(x, y)

    x_res, y_res = SMOTE(sampling_strategy='minority', random_state=42).fit_resample(x, y)

    return x_res, y_res
