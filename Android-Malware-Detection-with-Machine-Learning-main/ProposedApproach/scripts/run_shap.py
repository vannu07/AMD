"""
Compute SHAP explanations for the tuned Random Forest model and save summary plot and top features.
Run from repo root with:

. ProposedApproach/.venv/bin/activate
PYTHONPATH=ProposedApproach python ProposedApproach/scripts/run_shap.py

Outputs:
- ProposedApproach/results/shap_summary.png
- ProposedApproach/results/shap_top_features.json
- ProposedApproach/results/shap_values.npy (optional, may be large)
"""
import os
import json
import numpy as np
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

try:
    import shap
    import matplotlib.pyplot as plt
except Exception as e:
    logger.error('Missing required package: %s', e)
    raise

from MachineLearningModule.DataAcquisition.ReadDatasetFromCSV import get_dataset_from_csv_file
from MachineLearningModule.MachineLearningFlow import data_pre_processing
import joblib

ROOT = os.path.dirname(os.path.dirname(__file__))
DATASET_PATH = os.path.join(ROOT, 'Datasets', 'Drebin_v1.csv')
MODEL_PATHS = [
    os.path.join(ROOT, 'models', 'rf_tuned.pkl'),
    os.path.join(ROOT, 'models', 'final_model.pkl'),
    os.path.join('mlruns', '0', 'models', 'm-be60b01a4e0e4e448c31bb5f4d65db7d', 'artifacts', 'model.pkl')
]
OUT_DIR = os.path.join(ROOT, 'results')
os.makedirs(OUT_DIR, exist_ok=True)


def load_model():
    for p in MODEL_PATHS:
        if os.path.exists(p):
            logger.info('Loading model from %s', p)
            return joblib.load(p)
    raise FileNotFoundError('No model file found in expected locations.')


def main():
    dataset, class_name = get_dataset_from_csv_file(DATASET_PATH)
    x, y = data_pre_processing(dataset, class_name)

    model = load_model()

    # Only support tree-based explainer for tree models
    logger.info('Creating SHAP explainer...')
    try:
        explainer = shap.TreeExplainer(model)
    except Exception as e:
        logger.error('SHAP TreeExplainer failed: %s', e)
        # fallback to KernelExplainer (slower)
        explainer = shap.KernelExplainer(model.predict, shap.kmeans(x, 10))

    logger.info('Computing SHAP values (may take some time)...')
    shap_values = explainer.shap_values(x)

    # Save shap values (numpy)
    np.save(os.path.join(OUT_DIR, 'shap_values.npy'), shap_values)

    # Determine how shap_values is structured
    # For tree explainer with binary classification, shap_values can be array or list
    if isinstance(shap_values, list):
        # pick the explanation for class 1 if available
        if len(shap_values) == 2:
            sv = shap_values[1]
        else:
            sv = shap_values[0]
    else:
        sv = shap_values

    # Summary plot
    logger.info('Creating summary plot...')
    plt.figure(figsize=(10, 6))
    try:
        shap.summary_plot(sv, x, show=False)
        plt.tight_layout()
        out_png = os.path.join(OUT_DIR, 'shap_summary.png')
        plt.savefig(out_png, dpi=150)
        plt.close()
        logger.info('Saved SHAP summary plot to %s', out_png)
    except Exception as e:
        logger.error('Failed to create SHAP plot: %s', e)

    # Top features by mean(|shap|)
    mean_abs = np.mean(np.abs(sv), axis=0)
    feature_names = list(x.columns)
    idx = np.argsort(mean_abs)[::-1]
    top_features = [{'feature': feature_names[i], 'mean_abs_shap': float(mean_abs[i])} for i in idx[:30]]

    with open(os.path.join(OUT_DIR, 'shap_top_features.json'), 'w') as fh:
        json.dump(top_features, fh, indent=2)
    logger.info('Saved top SHAP features to %s', os.path.join(OUT_DIR, 'shap_top_features.json'))


if __name__ == '__main__':
    main()
